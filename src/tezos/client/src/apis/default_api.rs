/*
 * Tezos RPC
 *
 * Tezos client RPC API.
 *
 * The version of the OpenAPI document: 7.5
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `context_big_maps_big_map_id_script_expr_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextBigMapsBigMapIdScriptExprGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_constants_errors_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextConstantsErrorsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_constants_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextConstantsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_balance_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdBalanceGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_big_map_get_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdBigMapGetPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_counter_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdCounterGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_delegate_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdDelegateGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_entrypoints_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdEntrypointsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_entrypoints_string_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdEntrypointsStringGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_manager_key_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdManagerKeyGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_script_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdScriptGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_contract_id_storage_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsContractIdStorageGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_contracts_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextContractsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_balance_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhBalanceGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_deactivated_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhDeactivatedGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_delegated_balance_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhDelegatedBalanceGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_delegated_contracts_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhDelegatedContractsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_frozen_balance_by_cycle_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhFrozenBalanceByCycleGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_frozen_balance_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhFrozenBalanceGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_grace_period_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhGracePeriodGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_delegates_pkh_staking_balance_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextDelegatesPkhStakingBalanceGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_nonces_block_level_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextNoncesBlockLevelGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_raw_bytes_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextRawBytesGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `context_seed_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextSeedPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `endorsing_power_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndorsingPowerPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `hash_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HashGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `header_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeaderGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `header_protocol_data_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeaderProtocolDataGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `header_protocol_data_raw_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeaderProtocolDataRawGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `header_raw_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeaderRawGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `header_shell_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeaderShellGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_baking_rights_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersBakingRightsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_complete_prefix_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersCompletePrefixGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_current_level_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersCurrentLevelGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_endorsing_rights_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersEndorsingRightsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_forge_block_header_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersForgeBlockHeaderPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_forge_operations_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersForgeOperationsPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_forge_protocol_data_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersForgeProtocolDataPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_levels_in_current_cycle_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersLevelsInCurrentCycleGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_parse_block_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersParseBlockPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_parse_operations_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersParseOperationsPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_preapply_block_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersPreapplyBlockPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_preapply_operations_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersPreapplyOperationsPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_entrypoint_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsEntrypointPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_entrypoints_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsEntrypointsPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_pack_data_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsPackDataPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_run_code_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsRunCodePostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_run_operation_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsRunOperationPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_trace_code_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsTraceCodePostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_typecheck_code_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsTypecheckCodePostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `helpers_scripts_typecheck_data_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HelpersScriptsTypecheckDataPostError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `live_blocks_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LiveBlocksGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `metadata_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `minimal_valid_time_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MinimalValidTimeGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `operation_hashes_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OperationHashesGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `operation_hashes_list_offset_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OperationHashesListOffsetGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `operation_hashes_list_offset_operation_offset_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OperationHashesListOffsetOperationOffsetGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `operations_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OperationsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `operations_list_offset_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OperationsListOffsetGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `operations_list_offset_operation_offset_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OperationsListOffsetOperationOffsetGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `protocols_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProtocolsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `required_endorsements_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequiredEndorsementsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `root_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RootGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_ballot_list_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesBallotListGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_ballots_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesBallotsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_current_period_kind_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesCurrentPeriodKindGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_current_proposal_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesCurrentProposalGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_current_quorum_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesCurrentQuorumGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_listings_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesListingsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `votes_proposals_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesProposalsGetError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}


/// Access the value associated with a key in a big map.
pub async fn context_big_maps_big_map_id_script_expr_get(configuration: &configuration::Configuration, big_map_id: &str, script_expr: &str) -> Result<crate::models::Micheline007PsDelph1MichelsonV1Expression, Error<ContextBigMapsBigMapIdScriptExprGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/big_maps/{big_map_id}/{script_expr}", configuration.base_path, big_map_id=crate::apis::urlencode(big_map_id), script_expr=crate::apis::urlencode(script_expr));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextBigMapsBigMapIdScriptExprGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Schema for all the RPC errors from this protocol version
pub async fn context_constants_errors_get(configuration: &configuration::Configuration, ) -> Result<serde_json::Value, Error<ContextConstantsErrorsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/constants/errors", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextConstantsErrorsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All constants
pub async fn context_constants_get(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse2001, Error<ContextConstantsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/constants", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextConstantsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the balance of a contract.
pub async fn context_contracts_contract_id_balance_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<String, Error<ContextContractsContractIdBalanceGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/balance", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdBalanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the value associated with a key in a big map of the contract (deprecated).
pub async fn context_contracts_contract_id_big_map_get_post(configuration: &configuration::Configuration, contract_id: &str, inline_object: Option<crate::models::InlineObject>) -> Result<crate::models::OneOfobject, Error<ContextContractsContractIdBigMapGetPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/big_map_get", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdBigMapGetPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the counter of a contract, if any.
pub async fn context_contracts_contract_id_counter_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<String, Error<ContextContractsContractIdCounterGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/counter", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdCounterGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the delegate of a contract, if any.
pub async fn context_contracts_contract_id_delegate_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<crate::models::SignaturePublicKeyHash, Error<ContextContractsContractIdDelegateGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/delegate", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdDelegateGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return the list of entrypoints of the contract
pub async fn context_contracts_contract_id_entrypoints_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<crate::models::InlineResponse2003, Error<ContextContractsContractIdEntrypointsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/entrypoints", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdEntrypointsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return the type of the given entrypoint of the contract
pub async fn context_contracts_contract_id_entrypoints_string_get(configuration: &configuration::Configuration, contract_id: &str, string: &str) -> Result<crate::models::Micheline007PsDelph1MichelsonV1Expression, Error<ContextContractsContractIdEntrypointsStringGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/entrypoints/{string}", configuration.base_path, contract_id=crate::apis::urlencode(contract_id), string=crate::apis::urlencode(string));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdEntrypointsStringGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the complete status of a contract.
pub async fn context_contracts_contract_id_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<crate::models::InlineResponse2002, Error<ContextContractsContractIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the manager of a contract.
pub async fn context_contracts_contract_id_manager_key_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<crate::models::OneOfobject, Error<ContextContractsContractIdManagerKeyGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/manager_key", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdManagerKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the code and data of the contract.
pub async fn context_contracts_contract_id_script_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<crate::models::Model007PsDelph1ScriptedContracts, Error<ContextContractsContractIdScriptGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/script", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdScriptGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Access the data of the contract.
pub async fn context_contracts_contract_id_storage_get(configuration: &configuration::Configuration, contract_id: &str) -> Result<crate::models::Micheline007PsDelph1MichelsonV1Expression, Error<ContextContractsContractIdStorageGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts/{contract_id}/storage", configuration.base_path, contract_id=crate::apis::urlencode(contract_id));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsContractIdStorageGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All existing contracts (including non-empty default contracts).
pub async fn context_contracts_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::Model007PsDelph1ContractId>, Error<ContextContractsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/contracts", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextContractsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all registered delegates.
pub async fn context_delegates_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::SignaturePublicKeyHash>, Error<ContextDelegatesGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the full balance of a given delegate, including the frozen balances.
pub async fn context_delegates_pkh_balance_get(configuration: &configuration::Configuration, pkh: &str) -> Result<String, Error<ContextDelegatesPkhBalanceGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/balance", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhBalanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Tells whether the delegate is currently tagged as deactivated or not.
pub async fn context_delegates_pkh_deactivated_get(configuration: &configuration::Configuration, pkh: &str) -> Result<bool, Error<ContextDelegatesPkhDeactivatedGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/deactivated", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhDeactivatedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the balances of all the contracts that delegate to a given delegate. This excludes the delegate's own balance and its frozen balances.
pub async fn context_delegates_pkh_delegated_balance_get(configuration: &configuration::Configuration, pkh: &str) -> Result<String, Error<ContextDelegatesPkhDelegatedBalanceGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/delegated_balance", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhDelegatedBalanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of contracts that delegate to a given delegate.
pub async fn context_delegates_pkh_delegated_contracts_get(configuration: &configuration::Configuration, pkh: &str) -> Result<Vec<crate::models::Model007PsDelph1ContractId>, Error<ContextDelegatesPkhDelegatedContractsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/delegated_contracts", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhDelegatedContractsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the frozen balances of a given delegate, indexed by the cycle by which it will be unfrozen
pub async fn context_delegates_pkh_frozen_balance_by_cycle_get(configuration: &configuration::Configuration, pkh: &str) -> Result<Vec<crate::models::InlineResponse2004FrozenBalanceByCycle>, Error<ContextDelegatesPkhFrozenBalanceByCycleGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/frozen_balance_by_cycle", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhFrozenBalanceByCycleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the total frozen balances of a given delegate, this includes the frozen deposits, rewards and fees.
pub async fn context_delegates_pkh_frozen_balance_get(configuration: &configuration::Configuration, pkh: &str) -> Result<String, Error<ContextDelegatesPkhFrozenBalanceGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/frozen_balance", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhFrozenBalanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Everything about a delegate.
pub async fn context_delegates_pkh_get(configuration: &configuration::Configuration, pkh: &str) -> Result<crate::models::InlineResponse2004, Error<ContextDelegatesPkhGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the cycle by the end of which the delegate might be deactivated if she fails to execute any delegate action. A deactivated delegate might be reactivated (without loosing any rolls) by simply re-registering as a delegate. For deactivated delegates, this value contains the cycle by which they were deactivated.
pub async fn context_delegates_pkh_grace_period_get(configuration: &configuration::Configuration, pkh: &str) -> Result<i32, Error<ContextDelegatesPkhGracePeriodGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/grace_period", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhGracePeriodGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the total amount of tokens delegated to a given delegate. This includes the balances of all the contracts that delegate to it, but also the balance of the delegate itself and its frozen fees and deposits. The rewards do not count in the delegated balance until they are unfrozen.
pub async fn context_delegates_pkh_staking_balance_get(configuration: &configuration::Configuration, pkh: &str) -> Result<String, Error<ContextDelegatesPkhStakingBalanceGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/delegates/{pkh}/staking_balance", configuration.base_path, pkh=crate::apis::urlencode(pkh));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextDelegatesPkhStakingBalanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Info about the nonce of a previous block.
pub async fn context_nonces_block_level_get(configuration: &configuration::Configuration, block_level: &str) -> Result<crate::models::OneOfobjectobjectobject, Error<ContextNoncesBlockLevelGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/nonces/{block_level}", configuration.base_path, block_level=crate::apis::urlencode(block_level));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextNoncesBlockLevelGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the raw context.
pub async fn context_raw_bytes_get(configuration: &configuration::Configuration, ) -> Result<crate::models::RawContext, Error<ContextRawBytesGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/raw/bytes", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextRawBytesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Seed of the cycle to which the block belongs.
pub async fn context_seed_post(configuration: &configuration::Configuration, body: Option<serde_json::Value>) -> Result<String, Error<ContextSeedPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/context/seed", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ContextSeedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the endorsing power of an endorsement, that is, the number of slots that the endorser has
pub async fn endorsing_power_post(configuration: &configuration::Configuration, inline_object1: Option<crate::models::InlineObject1>) -> Result<i32, Error<EndorsingPowerPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/endorsing_power", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object1);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndorsingPowerPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The block's hash, its unique identifier.
pub async fn hash_get(configuration: &configuration::Configuration, ) -> Result<crate::models::BlockHash, Error<HashGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/hash", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HashGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The whole block header.
pub async fn header_get(configuration: &configuration::Configuration, ) -> Result<crate::models::BlockHeader, Error<HeaderGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/header", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeaderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The version-specific fragment of the block header.
pub async fn header_protocol_data_get(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse2005, Error<HeaderProtocolDataGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/header/protocol_data", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeaderProtocolDataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The version-specific fragment of the block header (unparsed).
pub async fn header_protocol_data_raw_get(configuration: &configuration::Configuration, ) -> Result<String, Error<HeaderProtocolDataRawGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/header/protocol_data/raw", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeaderProtocolDataRawGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The whole block header (unparsed).
pub async fn header_raw_get(configuration: &configuration::Configuration, ) -> Result<String, Error<HeaderRawGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/header/raw", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeaderRawGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The shell-specific fragment of the block header.
pub async fn header_shell_get(configuration: &configuration::Configuration, ) -> Result<crate::models::BlockHeaderShell, Error<HeaderShellGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/header/shell", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeaderShellGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves the list of delegates allowed to bake a block. By default, it gives the best baking priorities for bakers that have at least one opportunity below the 64th priority for the next block. Parameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the baking rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates. If parameter `all` is set, all the baking opportunities for each baker at each level are returned, instead of just the first one. Returns the list of baking slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.
pub async fn helpers_baking_rights_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::InlineResponse2006>, Error<HelpersBakingRightsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/baking_rights", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersBakingRightsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Try to complete a prefix of a Base58Check-encoded data. This RPC is actually able to complete hashes of block, operations, public_keys and contracts.
pub async fn helpers_complete_prefix_get(configuration: &configuration::Configuration, prefix: &str) -> Result<Vec<crate::models::Unistring>, Error<HelpersCompletePrefixGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/complete/{prefix}", configuration.base_path, prefix=crate::apis::urlencode(prefix));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersCompletePrefixGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the level of the interrogated block, or the one of a block located `offset` blocks after in the chain (or before when negative). For instance, the next block if `offset` is 1.
pub async fn helpers_current_level_get(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse2007, Error<HelpersCurrentLevelGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/current_level", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersCurrentLevelGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves the delegates allowed to endorse a block. By default, it gives the endorsement slots for delegates that have at least one in the next block. Parameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the endorsement rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates. Returns the list of endorsement slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.
pub async fn helpers_endorsing_rights_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::InlineResponse2008>, Error<HelpersEndorsingRightsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/endorsing_rights", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersEndorsingRightsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Forge a block header
pub async fn helpers_forge_block_header_post(configuration: &configuration::Configuration, block_header: Option<crate::models::BlockHeader>) -> Result<crate::models::InlineResponse20010, Error<HelpersForgeBlockHeaderPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/forge_block_header", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&block_header);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersForgeBlockHeaderPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Forge an operation
pub async fn helpers_forge_operations_post(configuration: &configuration::Configuration, model007_ps_delph1_operation_alpha_unsigned_operation: Option<crate::models::Model007PsDelph1OperationAlphaUnsignedOperation>) -> Result<String, Error<HelpersForgeOperationsPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/forge/operations", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&model007_ps_delph1_operation_alpha_unsigned_operation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersForgeOperationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Forge the protocol-specific part of a block header
pub async fn helpers_forge_protocol_data_post(configuration: &configuration::Configuration, inline_object2: Option<crate::models::InlineObject2>) -> Result<crate::models::InlineResponse2009, Error<HelpersForgeProtocolDataPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/forge/protocol_data", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersForgeProtocolDataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Levels of a cycle
pub async fn helpers_levels_in_current_cycle_get(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse20011, Error<HelpersLevelsInCurrentCycleGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/levels_in_current_cycle", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersLevelsInCurrentCycleGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Parse a block
pub async fn helpers_parse_block_post(configuration: &configuration::Configuration, block_header: Option<crate::models::BlockHeader>) -> Result<crate::models::Model007PsDelph1BlockHeaderAlphaSignedContents, Error<HelpersParseBlockPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/parse/block", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&block_header);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersParseBlockPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Parse operations
pub async fn helpers_parse_operations_post(configuration: &configuration::Configuration, inline_object3: Option<crate::models::InlineObject3>) -> Result<Vec<crate::models::EndorsingPowerEndorsementOperation>, Error<HelpersParseOperationsPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/parse/operations", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object3);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersParseOperationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Simulate the validation of a block that would contain the given operations and return the resulting fitness and context hash.
pub async fn helpers_preapply_block_post(configuration: &configuration::Configuration, inline_object4: Option<crate::models::InlineObject4>) -> Result<crate::models::InlineResponse20012, Error<HelpersPreapplyBlockPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/preapply/block", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object4);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersPreapplyBlockPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Simulate the validation of an operation.
pub async fn helpers_preapply_operations_post(configuration: &configuration::Configuration, next_operation: Option<Vec<crate::models::NextOperation>>) -> Result<Vec<crate::models::Model007PsDelph1OperationAlphaOperationWithMetadata>, Error<HelpersPreapplyOperationsPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/preapply/operations", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&next_operation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersPreapplyOperationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return the type of the given entrypoint
pub async fn helpers_scripts_entrypoint_post(configuration: &configuration::Configuration, inline_object5: Option<crate::models::InlineObject5>) -> Result<crate::models::InlineResponse20013, Error<HelpersScriptsEntrypointPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/entrypoint", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object5);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsEntrypointPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return the list of entrypoints of the given script
pub async fn helpers_scripts_entrypoints_post(configuration: &configuration::Configuration, inline_object6: Option<crate::models::InlineObject6>) -> Result<crate::models::InlineResponse2003, Error<HelpersScriptsEntrypointsPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/entrypoints", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object6);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsEntrypointsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Computes the serialized version of some data expression using the same algorithm as script instruction PACK
pub async fn helpers_scripts_pack_data_post(configuration: &configuration::Configuration, inline_object7: Option<crate::models::InlineObject7>) -> Result<crate::models::InlineResponse20014, Error<HelpersScriptsPackDataPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/pack_data", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object7);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsPackDataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Run a piece of code in the current context
pub async fn helpers_scripts_run_code_post(configuration: &configuration::Configuration, inline_object8: Option<crate::models::InlineObject8>) -> Result<crate::models::InlineResponse20015, Error<HelpersScriptsRunCodePostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/run_code", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object8);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsRunCodePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Run an operation without signature checks
pub async fn helpers_scripts_run_operation_post(configuration: &configuration::Configuration, inline_object9: Option<crate::models::InlineObject9>) -> Result<crate::models::Model007PsDelph1OperationAlphaOperationWithMetadata, Error<HelpersScriptsRunOperationPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/run_operation", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object9);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsRunOperationPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Run a piece of code in the current context, keeping a trace
pub async fn helpers_scripts_trace_code_post(configuration: &configuration::Configuration, inline_object10: Option<crate::models::InlineObject10>) -> Result<crate::models::InlineResponse20016, Error<HelpersScriptsTraceCodePostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/trace_code", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object10);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsTraceCodePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Typecheck a piece of code in the current context
pub async fn helpers_scripts_typecheck_code_post(configuration: &configuration::Configuration, inline_object11: Option<crate::models::InlineObject11>) -> Result<crate::models::InlineResponse20017, Error<HelpersScriptsTypecheckCodePostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/typecheck_code", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object11);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsTypecheckCodePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check that some data expression is well formed and of a given type in the current context
pub async fn helpers_scripts_typecheck_data_post(configuration: &configuration::Configuration, inline_object12: Option<crate::models::InlineObject12>) -> Result<crate::models::InlineResponse20018, Error<HelpersScriptsTypecheckDataPostError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/helpers/scripts/typecheck_data", configuration.base_path);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&inline_object12);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HelpersScriptsTypecheckDataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.
pub async fn live_blocks_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::BlockHash>, Error<LiveBlocksGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/live_blocks", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LiveBlocksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All the metadata associated to the block.
pub async fn metadata_get(configuration: &configuration::Configuration, ) -> Result<crate::models::BlockHeaderMetadata, Error<MetadataGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/metadata", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MetadataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Minimal valid time for a block given a priority and an endorsing power.
pub async fn minimal_valid_time_get(configuration: &configuration::Configuration, ) -> Result<crate::models::TimestampProtocol, Error<MinimalValidTimeGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/minimal_valid_time", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MinimalValidTimeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The hashes of all the operations included in the block.
pub async fn operation_hashes_get(configuration: &configuration::Configuration, ) -> Result<Vec<Vec<crate::models::OperationHash>>, Error<OperationHashesGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/operation_hashes", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OperationHashesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All the operations included in `n-th` validation pass of the block.
pub async fn operation_hashes_list_offset_get(configuration: &configuration::Configuration, list_offset: &str) -> Result<Vec<crate::models::OperationHash>, Error<OperationHashesListOffsetGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/operation_hashes/{list_offset}", configuration.base_path, list_offset=crate::apis::urlencode(list_offset));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OperationHashesListOffsetGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The hash of then `m-th` operation in the `n-th` validation pass of the block.
pub async fn operation_hashes_list_offset_operation_offset_get(configuration: &configuration::Configuration, list_offset: &str, operation_offset: &str) -> Result<crate::models::OperationHash, Error<OperationHashesListOffsetOperationOffsetGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/operation_hashes/{list_offset}/{operation_offset}", configuration.base_path, list_offset=crate::apis::urlencode(list_offset), operation_offset=crate::apis::urlencode(operation_offset));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OperationHashesListOffsetOperationOffsetGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All the operations included in the block.
pub async fn operations_get(configuration: &configuration::Configuration, ) -> Result<Vec<Vec<crate::models::Operation>>, Error<OperationsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/operations", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OperationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All the operations included in `n-th` validation pass of the block.
pub async fn operations_list_offset_get(configuration: &configuration::Configuration, list_offset: &str) -> Result<Vec<crate::models::Operation>, Error<OperationsListOffsetGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/operations/{list_offset}", configuration.base_path, list_offset=crate::apis::urlencode(list_offset));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OperationsListOffsetGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The `m-th` operation in the `n-th` validation pass of the block.
pub async fn operations_list_offset_operation_offset_get(configuration: &configuration::Configuration, list_offset: &str, operation_offset: &str) -> Result<crate::models::Operation, Error<OperationsListOffsetOperationOffsetGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/operations/{list_offset}/{operation_offset}", configuration.base_path, list_offset=crate::apis::urlencode(list_offset), operation_offset=crate::apis::urlencode(operation_offset));
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OperationsListOffsetOperationOffsetGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Current and next protocol.
pub async fn protocols_get(configuration: &configuration::Configuration, ) -> Result<::std::collections::HashMap<String, serde_json::Value>, Error<ProtocolsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/protocols", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProtocolsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Minimum number of endorsements for a block to be valid, given a delay of the block's timestamp with respect to the minimum time to bake at the block's priority
pub async fn required_endorsements_get(configuration: &configuration::Configuration, ) -> Result<i32, Error<RequiredEndorsementsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/required_endorsements", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RequiredEndorsementsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// All the information about a block. The associated metadata may not be present depending on the history mode and block's distance from the head.
pub async fn root_get(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse200, Error<RootGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RootGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Ballots casted so far during a voting period.
pub async fn votes_ballot_list_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::InlineResponse20019>, Error<VotesBallotListGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/ballot_list", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesBallotListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Sum of ballots casted so far during a voting period.
pub async fn votes_ballots_get(configuration: &configuration::Configuration, ) -> Result<crate::models::InlineResponse20020, Error<VotesBallotsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/ballots", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesBallotsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Current period kind.
pub async fn votes_current_period_kind_get(configuration: &configuration::Configuration, ) -> Result<crate::models::OneOfstringstringstringstring, Error<VotesCurrentPeriodKindGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/current_period_kind", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesCurrentPeriodKindGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Current proposal under evaluation.
pub async fn votes_current_proposal_get(configuration: &configuration::Configuration, ) -> Result<crate::models::OneOfobject, Error<VotesCurrentProposalGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/current_proposal", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesCurrentProposalGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Current expected quorum.
pub async fn votes_current_quorum_get(configuration: &configuration::Configuration, ) -> Result<i32, Error<VotesCurrentQuorumGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/current_quorum", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesCurrentQuorumGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of delegates with their voting weight, in number of rolls.
pub async fn votes_listings_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::InlineResponse20021>, Error<VotesListingsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/listings", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesListingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List of proposals with number of supporters.
pub async fn votes_proposals_get(configuration: &configuration::Configuration, ) -> Result<Vec<Vec<crate::models::OneOfProtocolHashinteger>>, Error<VotesProposalsGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/votes/proposals", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<VotesProposalsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

